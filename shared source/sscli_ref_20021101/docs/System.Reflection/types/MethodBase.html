<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Reflection.MethodBase</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Reflection.MethodBase Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.Reflection<br><dl>
<dt><b>Summary</b></dt>
<dd> Provides information about methods and constructors.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[Serializable]<br><b>public abstract class MethodBase : MemberInfo</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>MethodBase</b> is the base class of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> and  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a>.<br><br><b>Notes to inheritors: </b> When you inherit from <b>MethodBase</b>, you must override the following members:  <a href="#GetParameters">MethodBase.GetParameters</a>, the abstract overload of  <a href="#Invoke(System.Object,System.Object[])">MethodBase.Invoke</a>, and  <a href="#GetMethodImplementationFlags">MethodBase.GetMethodImplementationFlags</a>.</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Reflection/System.Reflection.html">System.Reflection Namespace</a></dd>
</dl>
<h3>System.Reflection.MethodBase Member List: </h3>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Attributes">Attributes</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the attributes associated with this method.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CallingConvention">CallingConvention</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating the calling conventions for this method.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DeclaringType">DeclaringType</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#DeclaringType">System.Reflection.MemberInfo.DeclaringType</a></font></b><br><br><br> Gets the class that declares this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAbstract">IsAbstract</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the method is <b>abstract</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAssembly">IsAssembly</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this method can be called by other classes in the same assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsConstructor">IsConstructor</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the method is a constructor.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsFamily">IsFamily</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether access to this method is restricted to members of the class and members of its derived classes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsFamilyAndAssembly">IsFamilyAndAssembly</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this method can be called by derived classes if they are in the same assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsFamilyOrAssembly">IsFamilyOrAssembly</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this method can be called by derived classes, wherever they are, and by all classes in the same assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsFinal">IsFinal</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this method is <b>final</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsHideBySig">IsHideBySig</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrivate">IsPrivate</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this member is private.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPublic">IsPublic</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this is a public method.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSpecialName">IsSpecialName</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether this method has a special name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsStatic">IsStatic</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the method is <b>static</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsVirtual">IsVirtual</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the method is <b>virtual</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberType">MemberType</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#MemberType">System.Reflection.MemberInfo.MemberType</a></font></b><br><br><br> Gets the type of this member, such as field, method, and so on.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MethodHandle">MethodHandle</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a handle to the internal metadata representation of a method.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Name">Name</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#Name">System.Reflection.MemberInfo.Name</a></font></b><br><br><br> Gets the name of this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReflectedType">ReflectedType</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#ReflectedType">System.Reflection.MemberInfo.ReflectedType</a></font></b><br><br><br> Gets the class object that was used to obtain this instance of <b>MemberInfo</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCurrentMethod">GetCurrentMethod</a></td>
<td width="55%"> Returns a <b>MethodBase</b> object representing the currently executing method.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Boolean)">GetCustomAttributes</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(bool inherit)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b><br><br><br> When overridden in a derived class, returns an array of all of the custom attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(Type attributeType, bool inherit)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Type,System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b><br><br><br> When overridden in a derived class, returns an array of custom attributes identified by  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethodFromHandle(System.RuntimeMethodHandle)">GetMethodFromHandle</a></td>
<td width="55%"> Gets method information by using the method's internal metadata representation (handle).</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethodImplementationFlags">GetMethodImplementationFlags</a></td>
<td width="55%"> When overridden in a derived class, returns the  <a href="../../System.Reflection/types/MethodImplAttributes.html">MethodImplAttributes</a> flags.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetParameters">GetParameters</a></td>
<td width="55%"> When overridden in a derived class, gets the parameters of the specified method or constructor.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Invoke(System.Object,System.Object[])">Invoke</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Invoke(object obj, object[] parameters)<br><br></code> Invokes the underlying method or constructor represented by this <b>MethodInfo</b> object with the specified parameters.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">Invoke</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture)<br><br></code> When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsDefined(System.Type,System.Boolean)">IsDefined</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">System.Reflection.MemberInfo.IsDefined</a></font></b><br><br><br> When overridden in a derived class, indicates whether one or more instance of <i>attributeType</i> is defined on this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Constructors</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ctor1">ctor #1</a></td>
<td width="55%">Default constructor. This constructor is called by derived class constructors to initialize state in this type.<br> Initializes a new instance of the  <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a> class.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System.Reflection/types/MemberInfo.html">System.Reflection.MemberInfo</a></li>
<ul class="none">
<li><b>System.Reflection.MethodBase</b><ul class="none">
<li><a href="../../System.Reflection/types/ConstructorInfo.html">System.Reflection.ConstructorInfo</a></li>
<li><a href="../../System.Reflection/types/MethodInfo.html">System.Reflection.MethodInfo</a></li>
</ul>
</li>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.Reflection.MethodBase Member Details</h3><b><i><a name=".ctorTopic1"></a><a name="ctor1">ctor #1</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the  <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a> class.</dd>
</dl><br><dl>
<dd>Default constructor. This constructor is called by derived class constructors to initialize state in this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected MethodBase();</b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AttributesTopic1"></a><a name="Attributes">Attributes</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the attributes associated with this method.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> Attributes {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> All members have a set of attributes, which are defined in relation to the specific type of member.<p> To get the <b>MethodAttributes</b>, first get the type. From the type, get the method. From the method, get the <b>MethodAttributes</b>.</p><br><br><b>Notes to implementors: </b> Use Attributes to determine whether a method is <b>public</b>, <b>private</b>, <b>final</b>, <b>virtual</b>, and so on.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

 using System;
 using System.Reflection;
 
 class AttributesSample
 {
    public void Mymethod (int int1m, out string str2m, ref string str3m)
    {
       str2m = "in Mymethod";
    }
 
    public static int Main(string[] args)
    {      
       Console.WriteLine ("Reflection.MethodBase.Attributes Sample");
       
       // Get our type
       Type MyType = Type.GetType("AttributesSample");
 
       // Get the method Mymethod on our type
       MethodBase Mymethodbase = MyType.GetMethod("Mymethod");
 
       // Print out the method
       Console.WriteLine("Mymethodbase = " + Mymethodbase);
 
       // Get the MethodAttribute enumerated value
       MethodAttributes Myattributes = Mymethodbase.Attributes;
 
       // print out the flags set
       PrintAttributes( typeof( System.Reflection.MethodAttributes ), (int) Myattributes );
       return 0;
    }
 
 
    public static void PrintAttributes( Type attribType, int iAttribValue )
    {
       if ( ! attribType.IsEnum ) { Console.WriteLine( "This type is not an enum" ); return; }
 
       FieldInfo[] fields = attribType.GetFields(BindingFlags.Public | BindingFlags.Static);
       for ( int i = 0; i &lt; fields.Length; i++ )
       {
          int fieldvalue = (Int32)fields[i].GetValue(null);
          if ( (fieldvalue &amp; iAttribValue) == fieldvalue )
          {
             Console.WriteLine( "\t" + fields[i].Name );
          }
       }
    }
 }
/* 
 This code produces the following output:
 
 Reflection.MethodBase.Attributes Sample
 Mymethodbase = Void Mymethod (Int32, System.String ByRef, System.String ByRef)
         PrivateScope
         FamANDAssem
         Family
         Public 
         HideBySig 
         ReuseSlot
*/

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="CallingConventionTopic1"></a><a name="CallingConvention">CallingConvention</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating the calling conventions for this method.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> CallingConvention {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="DeclaringTypeTopic1"></a><a name="DeclaringType">DeclaringType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#DeclaringType">System.Reflection.MemberInfo.DeclaringType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the class that declares this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> DeclaringType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <b>DeclaringType</b> property retrieves a reference to the  <a href="../../System/types/Type.html">Type</a> object for the type that declares this member. A member of a class (or interface) is either declared or inherited from a base class (or interface). The returned class might not be the same as the <b>Type</b> object used to obtain this  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> object.<UL>
<li> If the <b>Type</b> object from which this <b>MemberInfo</b> object was obtained did not declare this member, the <b>DeclaringType</b> will represent one of its base types.</li>
<li> If the <b>MemberInfo</b> object is a global member, (that is, it was obtained from  <a href="../../System.Reflection/types/Module.html#GetMethods">Module.GetMethods</a>, which returns global methods on a module), then the returned <b>DeclaringType</b> will be <b>null</b>.</li>
</UL>
</dd>
</dl><b>Example</b><dl>
<dd> The following example shows how <b>DeclaringType</b> works with classes and interfaces.<pre>

 interface i {
 int MyVar() ;
 };
 // DeclaringType for MyVar is i.
 
 class A : i {
 public int MyVar() { return 0; }
 };
 // DeclaringType for MyVar is A.
 
 class B : A {
 new int MyVar() { return 0; }
 };
 // DeclaringType for MyVar is B.
 
 class C : A {
 };
 // DeclaringType for MyVar is A.

    </pre>
<p> The following example uses <b>DeclaringType</b> to retrieve the member names of the <b>System.IO.BufferedStream</b> class, along with the class in which those members are declared.</p>
<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class Mymemberinfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo. 
    Type MyType =Type.GetType("System.IO.BufferedStream");
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method. 
    Console.Write("\nThere are {0} members in ", Mymemberinfoarray.Length); 
    Console.Write("{0}.", MyType.FullName); 
 
    foreach (MemberInfo Mymemberinfo in Mymemberinfoarray) {  
      Console.Write("\n" + Mymemberinfo.Name + " declaring type - "
        + Mymemberinfo.DeclaringType); 
    }
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> Reflection.MemberInfo </p>
<p> There are 31 members in System.IO.BufferedStream.</p>
<p> WriteByte declaring type - System.IO.BufferedStream </p>
<p> Write declaring type - System.IO.BufferedStream </p>
<p> ReadByte declaring type - System.IO.BufferedStream </p>
<p> Read declaring type - System.IO.BufferedStream </p>
<p> SetLength declaring type - System.IO.BufferedStream </p>
<p> Seek declaring type - System.IO.BufferedStream </p>
<p> EndWrite declaring type - System.IO.Stream </p>
<p> BeginWrite declaring type - System.IO.Stream </p>
<p> EndRead declaring type - System.IO.Stream </p>
<p> BeginRead declaring type - System.IO.Stream </p>
<p> Flush declaring type - System.IO.BufferedStream </p>
<p> Close declaring type - System.IO.BufferedStream </p>
<p> set_Position declaring type - System.IO.BufferedStream </p>
<p> get_Position declaring type - System.IO.BufferedStream </p>
<p> get_Length declaring type - System.IO.BufferedStream </p>
<p> get_CanWrite declaring type - System.IO.BufferedStream </p>
<p> get_CanSeek declaring type - System.IO.BufferedStream </p>
<p> get_CanRead declaring type - System.IO.BufferedStream </p>
<p> InitializeLifetimeService declaring type - System.MarshalByRefObject </p>
<p> GetHashCode declaring type - System.Object </p>
<p> Equals declaring type - System.Object </p>
<p> ToString declaring type - System.Object </p>
<p> GetLifetimeService declaring type - System.MarshalByRefObject </p>
<p> GetType declaring type - System.Object </p>
<p>.ctor declaring type - System.IO.BufferedStream </p>
<p>.ctor declaring type - System.IO.BufferedStream </p>
<p> CanRead declaring type - System.IO.BufferedStream </p>
<p> CanWrite declaring type - System.IO.BufferedStream </p>
<p> CanSeek declaring type - System.IO.BufferedStream </p>
<p> Length declaring type - System.IO.BufferedStream </p>
<p> Position declaring type - System.IO.BufferedStream </p><br><br><b>Note </b><b>DeclaringType</b> returns only the member names and the names of their declaring types. To return the member names with their prototypes, call <b>MemberInfo.ToString</b>.<p> In the following code example, when B overrides virtual method M from A, it essentially redefines (or redeclares) this method. Therefore, B.M's <b>MethodInfo</b> reports the declaring type as B rather than A, even though A is where this method was originally declared.</p>
<pre>
class A {
    virtual public void M () {}
}
class B: A {
    override public void M () {}
}

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAbstractTopic1"></a><a name="IsAbstract">IsAbstract</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the method is <b>abstract</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAbstract {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> An abstract member is declared on a base class and has no implementation supplied.<p> To get the  <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a>, first get the type. From the type, get the method. From the method, get the <b>MethodBase</b>. If the <b>MethodBase</b> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> mask to <b>NonPublic</b> in <b>GetMethod</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
 class methodbase
 {
    public static int Main(string[] args)
    {      
       Console.WriteLine ("\nReflection.MethodBase");
       
       //Get the MethodBase of two methods.
 
       //Get the types
       Type MyType1 = Type.GetType("System.Runtime.Serialization.Formatter");       
       Type MyType2 = Type.GetType("System.Reflection.MethodBase");
 
       //Get and display the methods
       MethodBase Mymethodbase1 = 
          MyType1.GetMethod("WriteInt32", BindingFlags.NonPublic|BindingFlags.Instance);

       MethodBase Mymethodbase2 = 
          MyType2.GetMethod("GetCurrentMethod", BindingFlags.Public|BindingFlags.Static);
 
       Console.Write("\nMymethodbase = " + Mymethodbase1.ToString());
       if (Mymethodbase1.IsAbstract)
          Console.Write ("\nMymethodbase is an abstract method");
       else
          Console.Write ("\nMymethodbase is not an abstract method");
 
       Console.Write("\n\nMymethodbase = " + Mymethodbase2.ToString());
       if (Mymethodbase2.IsAbstract)
          Console.Write ("\nMymethodbase is an abstract method");
       else
          Console.Write ("\nMymethodbase is not an abstract method");
       
       return 0;
    }
 }
 /*
 Produces the following output
 Reflection.MethodBase
 
 Mymethodbase = Void WriteInt32 (Int32, System.String)
 Mymethodbase is an abstract method
 
 Mymethodbase = System.Reflection.MethodBase GetCurrentMethod ()
 Mymethodbase is not an abstract method
 */

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAssemblyTopic1"></a><a name="IsAssembly">IsAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this method can be called by other classes in the same assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If set, this method can be called by other classes in the same assembly.<p> To get the  <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a>, first get the type. From the type, get the method. From the method, get the <b>MethodBase</b>. If the <b>MethodBase</b> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> mask to <b>NonPublic</b> in <b>GetMethod</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
 class methodbase
 {
	internal void f() { }
    public static int Main(string[] args)
    { 
       Console.WriteLine ("\nReflection.MethodBase");
       
       //Get the MethodBase of two methods.
 
       //Get the types
       Type MyType1 = Type.GetType("System.Runtime.Serialization.Formatter");
       Type MyType2 = Type.GetType("methodbase");
 
       //Get and display the methods and the IsAssembly
       MethodBase Mymethodbase1 = 
          MyType1.GetMethod("WriteInt32",BindingFlags.NonPublic|BindingFlags.Instance);
       MethodBase Mymethodbase2 = 
          MyType2.GetMethod("f", BindingFlags.NonPublic|BindingFlags.Instance);
 
       Console.Write("\nMymethodbase = " + Mymethodbase1.ToString());
       if (Mymethodbase1.IsAssembly)
          Console.Write ("\nMymethodbase is an assembly method");
       else
          Console.Write ("\nMymethodbase is not an assembly method");
 
       Console.Write("\n\nMymethodbase = " + Mymethodbase2.ToString());
       if (Mymethodbase2.IsAssembly)
          Console.Write ("\nMymethodbase is an assembly method");
       else
          Console.Write ("\nMymethodbase is not an assembly method");
       
       return 0;
    }
 }
 /*
 Produces the following output
 Reflection.MethodBase
 
 Mymethodbase = Void WriteInt32 (Int32, System.String)
 Mymethodbase is not an assembly method
 
 Mymethodbase = Void f()
 Mymethodbase is an assembly method
 */

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> |  <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsConstructorTopic1"></a><a name="IsConstructor">IsConstructor</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the method is a constructor.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsConstructor {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsFamilyTopic1"></a><a name="IsFamily">IsFamily</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether access to this method is restricted to members of the class and members of its derived classes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsFamily {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a type member has <b>Family</b> level visibility it can be called from any member in a derived class, but not from any other type.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsFamilyAndAssemblyTopic1"></a><a name="IsFamilyAndAssembly">IsFamilyAndAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this method can be called by derived classes if they are in the same assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsFamilyAndAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsFamilyOrAssemblyTopic1"></a><a name="IsFamilyOrAssembly">IsFamilyOrAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this method can be called by derived classes, wherever they are, and by all classes in the same assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsFamilyOrAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a type member has <b>FamilyOrAssembly</b> level visibility it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsFinalTopic1"></a><a name="IsFinal">IsFinal</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this method is <b>final</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsFinal {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> To determine if a method is overridable, it is not sufficient to check that  <a href="#IsVirtual">MethodBase.IsVirtual</a> is <b>true</b>. For a method to be overridable, <b>IsVirtual</b> must be <b>true</b> and <b>IsFinal</b> must be <b>false</b>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <b>virtual</b>; therefore, the compiler marks the method <b>virtual</b><b>final</b>. So there are cases where a method is marked as <b>virtual</b> but is still not overridable.<p> To establish with certainty whether a method is overridable, use code such as this: </p><code>
              if (MethodInfo.IsVirtual &amp;&amp; !MethodInfo.IsFinal)
            </code><p> If <b>IsVirtual</b> is <b>false</b> or <b>IsFinal</b> is <b>true</b>, then the method cannot be overridden.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example prints <b>false</b> for <b>IsFinal</b>, which might lead you to think that MyMethod is overridable. The code prints <b>false</b> even though MyMethod is not marked <b>virtual</b> and thus cannot be overridden.<pre>
 using System;
 using System.Reflection;
 
 public class MyClass 
 {
 public void MyMethod() 
   {
   }
 public static void Main() 
   {
    MethodBase m = typeof(MyClass).GetMethod("MyMethod");
    Console.WriteLine(m.IsFinal);
   }
 }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsHideBySigTopic1"></a><a name="IsHideBySig">IsHideBySig</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsHideBySig {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPrivateTopic1"></a><a name="IsPrivate">IsPrivate</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this member is private.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPrivate {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a type member has <b>Private</b> level visibility, it can be called from any member in the same class and no others.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPublicTopic1"></a><a name="IsPublic">IsPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this is a public method.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> To get the  <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a>, first get the type. From the type, get the method. From the method, get the <b>MethodBase</b>. If the <b>MethodBase</b> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> mask to <b>NonPublic</b> in <b>GetMethod</b>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
 class methodbase
 {
    public static int Main(string[] args)
    {     
 
       Console.WriteLine("\nReflection.MethodBase");
       
       //Get the MethodBase of a method.
  
       //Get the type
       Type MyType = Type.GetType("System.MulticastDelegate");
  
       //Get and display the method
       MethodBase Mymethodbase =
          MyType.GetMethod("RemoveImpl",BindingFlags.NonPublic);
  
       Console.Write("\nMymethodbase = " + Mymethodbase);
  
       bool Myispublic = Mymethodbase.IsPublic;
       if (Myispublic)
          Console.Write ("\nMymethodbase is a public method");
       else
          Console.Write ("\nMymethodbase is not a public method");
       
       return 0;
    }
 }
 /*
 Produces the following output
 
 Reflection.MethodBase
 Mymethodbase = System.Delegate RemoveImpl (System.Delegate)
 Mymethodbase is not a public method
 */

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSpecialNameTopic1"></a><a name="IsSpecialName">IsSpecialName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this method has a special name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSpecialName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/MethodAttributes.html#SpecialName">MethodAttributes.SpecialName</a> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsStaticTopic1"></a><a name="IsStatic">IsStatic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the method is <b>static</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsStatic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A static member cannot implicitly reference instance data in a class (see <b>MethodAttributes.</b><b>Static</b>).</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsVirtualTopic1"></a><a name="IsVirtual">IsVirtual</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the method is <b>virtual</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsVirtual {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A virtual member may reference instance data in a class and must be referenced through an instance of the class.<p> To determine if a method is overridable, it is not sufficient to check that <b>IsVirtual</b> is <b>true</b>. For a method to be overridable, <b>IsVirtual</b> must be <b>true</b> and  <a href="#IsFinal">MethodBase.IsFinal</a> must be <b>false</b>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <b>virtual</b>; therefore, the compiler marks the method <b>virtual</b><b>final</b>. So there are cases where a method is marked as <b>virtual</b> but is still not overridable.</p>
<p> To establish with certainty whether a method is overridable, use code such as this: </p><code>
              if (MethodInfo.IsVirtual &amp;&amp; !MethodInfo.IsFinal)
            </code><p> If <b>IsVirtual</b> is <b>false</b> or <b>IsFinal</b> is <b>true</b>, then the method cannot be overridden.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example prints <b>false</b> for <b>IsFinal</b>, which might lead you to think that MyMethod is overridable. The code prints <b>false</b> even though MyMethod is not marked <b>virtual</b> and thus cannot be overridden.<pre>
 using System;
 using System.Reflection;
 
 public class MyClass 
 {
 public void MyMethod() 
   {
   }
 public static void Main() 
   {
    MethodBase m = typeof(MyClass).GetMethod("MyMethod");
    Console.WriteLine(m.IsFinal);
   }
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="MemberTypeTopic1"></a><a name="MemberType">MemberType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#MemberType">System.Reflection.MemberInfo.MemberType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the type of this member, such as field, method, and so on.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> MemberType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> To get the <b>MemberType</b> property, get the class  <a href="../../System/types/Type.html">Type</a>. From the <b>Type</b>, get the  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> array. From the <b>MethodInfo</b> array, get the <b>MemberTypes</b>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
 
 class Mymemberinfo
 {
    public static int Main()
    {
       Console.WriteLine ("\nReflection.MemberInfo");
       
       //Get the Type and MemberInfo.
       Type MyType = Type.GetType("System.Reflection.PropertyInfo");
       MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
  
       //Get the MemberType method and display the elements.
       Console.Write("\nThere are {0} members in ",
          Mymemberinfoarray.GetLength(0));
       Console.Write("{0}.", MyType.FullName);
  
       for (int counter = 0; counter &lt; Mymemberinfoarray.Length; counter++)
       {
          Console.Write("\n" + counter + ". " 
             + Mymemberinfoarray[counter].Name
             + " Member type - " +
             Mymemberinfoarray[counter].MemberType.ToString());
       }
       return 0;
    }
 }
 /*
 This code produces the following output:
 Reflection.MemberInfo
  
 There are 52 members in System.Reflection.PropertyInfo.
 37. GetCanRead Member type - Method
 38. GetCanWrite Member type - Method
 39. MemberType Member type - Property
 40. PropertyType Member type - Property
 */

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="MethodHandleTopic1"></a><a name="MethodHandle">MethodHandle</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a handle to the internal metadata representation of a method.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/RuntimeMethodHandle.html">RuntimeMethodHandle</a> MethodHandle {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The handles are valid only in the application domain in which they were obtained.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="NameTopic1"></a><a name="Name">Name</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#Name">System.Reflection.MemberInfo.Name</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the name of this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/String.html">string</a> Name {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Only the simple name is returned, not the fully qualified name. For example, for a member System.Reflection.MemberTypes.Field, the Name property would be Field.<p> To get the Name property, get the class  <a href="../../System/types/Type.html">Type</a>. From the <b>Type</b>, get the  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> array. From a <b>MemberInfo</b> element of the array, obtain the <b>Name</b> property.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example lists the <b>Name</b> and <b>DeclaringType</b> property of each member of the <b>System.Empty</b> class.<pre>
using System;
using System.Reflection;
 
class Mymemberinfo
 {
    public static int Main()
    {
       Console.WriteLine ("\nReflection.MemberInfo");
       
       //Get the Type and MemberInfo.
       Type MyType = Type.GetType("System.Empty");
       MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
  
       //Get and display the DeclaringType method.
       Console.Write("\nThere are {0} members in ",
          Mymemberinfoarray.GetLength(0));
       Console.Write("{0}.", MyType.FullName);
  
       foreach (MemberInfo Mymemberinfo in Mymemberinfoarray)
       {
          Console.Write("\n" + Mymemberinfo.Name
             + " declaring type - " +
              Mymemberinfo.DeclaringType);
       }
  
       return 0;
    }
 }
 /*
 This code produces the following output:

Reflection.MemberInfo

There are 6 members in System.Empty.
Value declaring type - System.Empty
GetObjectData declaring type - System.Empty
GetHashCode declaring type - System.Object
Equals declaring type - System.Object
ToString declaring type - System.Empty
GetType declaring type - System.Object
 */

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="ReflectedTypeTopic1"></a><a name="ReflectedType">ReflectedType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#ReflectedType">System.Reflection.MemberInfo.ReflectedType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the class object that was used to obtain this instance of <b>MemberInfo</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> ReflectedType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <b>ReflectedType</b> property retrieves the  <a href="../../System/types/Type.html">Type</a> object that was used to obtain this instance of <b>MemberInfo</b>. A  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> object represents a member of a particular class or interface.<p> In order to obtain a <b>MethodInfo</b> object: </p>
<UL>
<li> The <b>Type</b> object that represents the class or interface that supports the method is queried. This property holds a reference to that <b>Type</b> object.</li>
<li> If the reflected type is the same class as the declaring class, the member is defined on the declaring class, not on a superclass.</li>
<li> If the <b>MemberInfo</b> object is a global member, (that is, it was obtained from  <a href="../../System.Reflection/types/Module.html#GetMethods">Module.GetMethods</a>, which returns global methods on a module), then the returned <b>DeclaringType</b> will be <b>null</b>.</li>
</UL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class Mymemberinfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo  
    Type MyType =Type.GetType("System.IO.BufferedStream"); 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers(); 
 
    //Get and display the DeclaringType method 
    Console.Write("\nThere are {0} members in ", Mymemberinfoarray.Length); 
    Console.Write("{0}.", MyType.FullName); 
 
    foreach (MemberInfo Mymemberinfo in Mymemberinfoarray) { 
      Console.Write("\n" + Mymemberinfo.Name + " reflected type - " +
         Mymemberinfo.ReflectedType);
    }
   }
 }

    </pre> This code produces the following output: <p> Reflection.MemberInfo </p>
<p> There are 31 members in System.IO.BufferedStream.</p>
<p> WriteByte reflected type - System.IO.BufferedStream </p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~MethodBase();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetCurrentMethodTopic1"></a><a name="GetCurrentMethod">GetCurrentMethod</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns a <b>MethodBase</b> object representing the currently executing method.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a> GetCurrentMethod();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A <b>MethodBase</b> object representing the currently executing method.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic1"></a><a name="GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns an array of all of the custom attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of all the custom attributes, or an array with zero elements if no attributes are defined.</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;

// Define a custom attribute with one named parameter.
[AttributeUsage(AttributeTargets.All)]
public class MyAttribute : Attribute
{
   private string myName;
   public MyAttribute(string name)
   {
      myName = name;
   }
   public string Name
   {
      get
      {
         return myName;
      }
   }
}

// Define a class which has the custom attribute associated with one of its members.
public class MyClass1
{
   [MyAttribute("This is an example attribute")]
   public void MyMethod(int i)
   {
      return;
   }
}

public class MemberInfo_GetCustomAttributes
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass1'.
         Type myType = typeof(MyClass1);
         // Get the members associated with the class 'MyClass1'.
         MemberInfo[] myMembers = myType.GetMembers();

         // Display the attributes for each of the members of the class 'MyClass1'.
         for(int i = 0; i &lt; myMembers.Length; i++)
         {
            Object[] myAttributes = myMembers[i].GetCustomAttributes(false);
            if(myAttributes.Length &gt; 0)
            {
               Console.WriteLine("\nThe attributes for the member {0} are : \n", myMembers[i]);
               for(int j = 0; j &lt; myAttributes.Length; j++)
                  Console.WriteLine("The type of the attribute is : {0}", myAttributes[j]);
            }
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception Caught! "+e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Object.html">Object</a> |  <a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic2"></a><a name="GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Type,System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns an array of custom attributes identified by  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The type of attribute to search for. Only attributes that are assignable to this type are returned.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of custom attributes defined on this reflected member, or an array with zero (0) elements if no attributes are defined.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/TypeLoadException.html">TypeLoadException</a></td>
<td> If the custom attribute type can not be loaded.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Type,System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetMethodFromHandleTopic1"></a><a name="GetMethodFromHandle(System.RuntimeMethodHandle)">GetMethodFromHandle</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/RuntimeMethodHandle.html">RuntimeMethodHandle</a> <i>handle</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets method information by using the method's internal metadata representation (handle).</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Reflection/types/MethodBase.html">MethodBase</a> GetMethodFromHandle(<br>   <font color="#008080"><a href="../../System/types/RuntimeMethodHandle.html">RuntimeMethodHandle</a> <i>handle</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>handle</i><br><dl>
<dd>
<param> The method's handle.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>MethodBase</b> information about the method.</dd>
</dl><b>Remarks</b><dl>
<dd> The handles are valid only in the application domain in which they were obtained.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetMethodImplementationFlagsTopic1"></a><a name="GetMethodImplementationFlags">GetMethodImplementationFlags</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns the  <a href="../../System.Reflection/types/MethodImplAttributes.html">MethodImplAttributes</a> flags.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/MethodImplAttributes.html">MethodImplAttributes</a> GetMethodImplementationFlags();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The <b>MethodImplAttributes</b> flags.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodImplAttributes.html">MethodImplAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetParametersTopic1"></a><a name="GetParameters">GetParameters</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets the parameters of the specified method or constructor.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/ParameterInfo.html">ParameterInfo[]</a> GetParameters();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of type <b>ParameterInfo</b> containing information that matches the signature of the method (or constructor) reflected by this <b>MethodBase</b> instance.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ParameterInfo.html">ParameterInfo</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeTopic1"></a><a name="Invoke(System.Object,System.Object[])">Invoke</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>parameters</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the underlying method or constructor represented by this <b>MethodInfo</b> object with the specified parameters.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> Invoke(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>parameters</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>obj</i><br><dl>
<dd>
<param> The instance that created this method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameters</i><br><dl>
<dd>
<param> An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <b>null</b>.<p> If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. If the parameters contain an uninitialized object, it is treated as <b>System.Empty</b>, which, with the default binder, can be widened to 0, 0.0 or <b>String</b>.</p> An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <b>null</b>.<p> If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. If the parameters contain an uninitialized object, it is treated as <b>System.Empty</b>, which, with the default binder, can be widened to 0, 0.0 or <b>String</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An <b>Object</b> containing the return value of the invoked method, or a re-initialized object in the case of a constructor.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The <i>obj</i> parameter is <b>null</b> and the method is not static.<p> -or- </p>
<p> The method is not declared or inherited by the class of <i>obj</i>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The type of the <i>parameters</i> parameter does not match the signature of the method or constructor reflected by this instance.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The caller does not have permission to invoke the method or constructor.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> The invoked method or constructor throws an exception.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetParameterCountException.html">TargetParameterCountException</a></td>
<td> The <i>parameters</i> array does not have the correct number of arguments.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MethodAccessException.html">MethodAccessException</a></td>
<td> The caller does not have permission to execute the constructor.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use this method to invoke methods with parameters that have default values. To bind to these methods, Reflection requires one of the binding flags <b>DefaultValueBinding</b>, <b>DefaultValueChangeType</b>, or <b>DefaultValueFull</b> to be specified explicitly. This is a requirement even in those cases where a value is passed for a parameter that has a default value.<p> For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <b>Missing.Value</b> for the second argument. Unless you use <b>Missing.Value</b>, you may not omit optional parameters with the <b>Invoke</b> method. If you must do so, use  <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">Type.InvokeMember</a> instead.</p>
<p> This is a convenience method that calls the following <b>Invoke</b> method, passing <b>null</b> in the other parameters. If the invoked method throws an exception,  <a href="../../System/types/Exception.html#GetBaseException">Exception.GetBaseException</a> returns the exception.</p>
<p> To invoke a static method using its  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object, the first parameter should be <b>null</b>, as shown in the following call: </p>
<p><code>
                Object myReturnValue =
                myMethodInfo.Invoke(null, myParametersArray);
              </code></p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Missing.html">Missing</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeTopic2"></a><a name="Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">Invoke</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>parameters</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object</a> Invoke(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>parameters</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>obj</i><br><dl>
<dd>
<param> The object on which to invoke the method or constructor. If the method or constructor is static, this argument is ignored.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask that is a combination of 0 or more bit flags from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as <b>DefaultBinding</b>, <b>NonPublic</b>, and so on. If <i>binder</i> is <b>null</b>, this parameter will be assigned the value <b>BindingFlags.DefaultBinding</b>; thus, whatever you pass in is ignored.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <b>MemberInfo</b> objects via reflection. If <i>binder</i> is <b>null</b>, the default binder is used.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameters</i><br><dl>
<dd>
<param> An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <b>null</b>.<p> If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. If the parameters contain an uninitialized object, it is treated as <b>System.Empty</b>, which, with the default binder, can be widened to 0, 0.0 or <b>String</b>.</p> An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <b>null</b>.<p> If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. If the parameters contain an uninitialized object, it is treated as <b>System.Empty</b>, which, with the default binder, can be widened to 0, 0.0 or <b>String</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> An instance of <b>CultureInfo</b> used to govern the coercion of types. If this is <b>null</b>, the <b>CultureInfo</b> for the current thread is used. (This is necessary to convert a <b>String</b> that represents 1000 to a <b>Double</b> value, for example, since 1000 is represented differently by different cultures.) 
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An <b>Object</b> containing the return value of the invoked method, or a reinitialized object in the case of a constructor, or <b>null</b> if the method's return type is <b>void</b>. Before calling the method or constructor, <b>Invoke</b> checks to see if the user has access permission and verify that the parameters are valid.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The <i>obj</i> parameter is <b>null</b> and the method is not static. -or- <p> The method is not declared or inherited by the class of <i>obj</i>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The type of the <i>parameters</i> parameter does not match the signature of the method or constructor reflected by this instance.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The caller does not have permission to invoke the method or constructor.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> The invoked method or constructor throws an exception.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MethodAccessException.html">MethodAccessException</a></td>
<td> The caller does not have permission to execute the constructor.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Dynamically invokes the method reflected by this instance on <i>obj</i>, and passes along the specified parameters. If the method is static, the <i>obj</i> parameter is ignored. For non-static methods, <i>obj</i> should be an instance of a class that inherits or declares the method and must be the same type as this class. If the method has no parameters, the value of <i>parameters</i> should be <b>null</b>. Otherwise, the number, type, and order of elements in <i>parameters</i> should be identical to the number, type, and order of parameters for the method reflected by this instance.<p> You may not omit optional parameters in calls to <b>Invoke</b>. To invoke a method omitting optional parameters, you should call <b>Type.InvokeMember</b> instead.</p>
<p> For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example). For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type). However, for pass-by-reference primitive parameters, the types must match exactly. For pass-by-reference reference parameters, the normal widening still applies.</p>
<p> For example, if the method reflected by this instance is declared as <code>
                public boolean
                Compare(String a, String b)
              </code>, then <i>parameters</i> should be an array of <b>Objects</b> with length 2 such that <code>
                parameters[0] = new
                Object("SomeString1") and parameters[1] = new Object("SomeString2")
              </code>.</p>
<p> Reflection uses dynamic method lookup when invoking virtual methods. For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <b>MethodInfo</b> object that represents M on class A. If you use the <b>Invoke</b> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</p>
<p> On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <b>MethodInfo</b> was obtained, regardless of the type of the object passed as the target.</p>
<p> Access restrictions are ignored for fully trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</p>
<p> If the invoked method throws an exception, <b>TargetInvocationException.GetException</b> returns the exception. This implementation throws a <b>NotSupportedException</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following samples in C++ and C# demonstrate dynamic method lookup using reflection. Note that all of the invocations return 1, because the method in classes A and B is virtual.<pre>
 public class A
 {
    public virtual int method () {return 0;}
 }
 
 public class B
 {
    public virtual int method () {return 1;}
 }
 
 class Mymethodinfo
 {
    public static int Main()
    {
       Console.WriteLine ("\nReflection.MethodInfo");
       A MyA = new A();
       B MyB = new B();
 
       //Get the Type and MethodInfo
       Type MyTypea = Type.GetType("A");
       MethodInfo Mymethodinfoa = MyTypea.GetMethod("method");
 
       Type MyTypeb = Type.GetType("B");
       MethodInfo Mymethodinfob = MyTypeb.GetMethod("method");
 
       //Get and display the Invoke method
       Console.Write("\nFirst method - " + MyTypea.FullName +
          " returns " + Mymethodinfoa.Invoke(MyA, null));
       Console.Write("\nSecond method - " + MyTypeb.FullName +
          " returns " + Mymethodinfob.Invoke(MyB, null));
 
       return 0;
    }
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsDefinedTopic1"></a><a name="IsDefined(System.Type,System.Boolean)">IsDefined</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">System.Reflection.MemberInfo.IsDefined</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, indicates whether one or more instance of <i>attributeType</i> is defined on this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Boolean.html">bool</a> IsDefined(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The <b>Type</b> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if one or more instance of <i>attributeType</i> is defined on this member; otherwise <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#IsDefined(System.Type,System.Boolean)">ICustomAttributeProvider.IsDefined</a></dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;

// Define a custom attribute with one named parameter.
[AttributeUsage(AttributeTargets.All)]
public class MyAttribute : Attribute
{
   private string myName;
   public MyAttribute(string name)
   {
      myName = name;
   }
   public string Name
   {
      get
      {
         return myName;
      }
   }
}

// Define a class which has the custom attribute associated with one of its members.
public class MyClass1
{
   [MyAttribute("This is an example attribute")]
   public void MyMethod(int i)
   {
      return;
   }
}

public class MemberInfo_GetCustomAttributes_IsDefined
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass1'.
         Type myType = typeof(MyClass1);
         // Get the members associated with the class 'MyClass1'.
         MemberInfo[] myMembers = myType.GetMembers();

         // Display the attributes for each of the members of the class 'MyClass1'.
         for(int i = 0; i &lt; myMembers.Length; i++)
         {
            // Display the attribute if it is of type 'MyAttribute'.
            if(myMembers[i].IsDefined(typeof(MyAttribute), false))
            {
               Object[] myAttributes = myMembers[i].GetCustomAttributes(typeof(MyAttribute), false);
               Console.WriteLine("\nThe attributes of type 'MyAttribute' for the member {0} are : \n",
                                    myMembers[i]);
               for(int j = 0; j &lt; myAttributes.Length; j++)
                  // Display the value associated with the attribute.
                  Console.WriteLine("The value of the attribute is : \"{0}\"",
                                       ((MyAttribute)myAttributes[j]).Name);
            }
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception Caught! "+e.Message);
      }
   }
}

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual string ToString();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
